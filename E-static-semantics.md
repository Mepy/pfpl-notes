## 语言E的静态语义
### 简介
我们早在学 C 语言时, 就已经得到 **类型 Type** 的概念.
从语言 E 的动态语义中也有直觉, 我们需要 **类型 Type** 来确保语义不卡住.
但是我们对类型的理解, 不只是 C 语言中的内存布局. 
类型或者说静态语义, 不运行程序也能保证程序不卡住, 这一性质非常良好.
在计算理论的语境下, 程序不卡住是一个非平凡的性质, 可能导致停机问题.
不过幸运的是, 语言 E 显然没有图灵完备性, 语言 E 的类型赋予问题是可计算的.

为表达式赋予类型这一行为, 称作 **赋型 Typing**.
Typing 不译作"定型", 一者"定型"有偏正结构的歧义, 即"特定类型";
二来"定"有"确定性"的含义, 而我们到动态类型时便会明白, 类型不一定唯一.

由于 let 运算符, 我们引入绑定变量作为上下文, 
$\text{plus}(x; \text{nat[1]})$ 是否卡住依赖于变量 $x$ 的类型,
因此, 赋型判断是由泛型假言规则归纳定义的泛型判断.
同时, 遵循 **标识约定 identification convention**, 始终保证变量 **新 fresh**.

注意, 本节使用结构化动态语义进行类型安全的证明.

### 赋型
赋型判断 $Γ⊢e:τ$ 由以下规则归纳定义:
$$
\tag{4.1a, 变量}
\dfrac
{}
{Γ, x:τ⊢x:τ}
$$
注意, $⊢$ 左侧的 $Γ, x:τ$ 代表 $x:τ∈Γ'=Γ∪{x:τ}$ 并强调其在上下文中.
$$
\tag{4.1b, 自然数}
\dfrac
{}
{Γ⊢\text{nat[n]}:\text{nat}}
$$
$$
\tag{4.1c, 布尔真}
\dfrac
{}
{Γ⊢\text{true}:\text{bool}}
$$
$$
\tag{4.1d, 布尔假}
\dfrac
{}
{Γ⊢\text{false}:\text{bool}}
$$
$$
\tag{4.1e, 加法}
\dfrac
{Γ⊢e_1:\text{nat} \ \ Γ⊢e_2:\text{nat}}
{Γ⊢\text{plus}(e_1; e_2):\text{nat}}
$$
$$
\tag{4.1f, 否定}
\dfrac
{Γ⊢e:\text{bool}}
{Γ⊢\text{not}(e):\text{bool}}
$$
$$
\tag{4.1g, LET}
\dfrac
{Γ⊢e_1:τ_1 \ \ Γ, x:τ_1⊢e_2:τ_2}
{Γ⊢\text{let}(e_1; x.e_2):τ_2}
$$

### 赋型基础性质
这样定义的赋型判断有许多有用的基础性质, 我们先行叙述如下:

引理 (4.1, 赋得型唯一 Uniqueness) : $∀Γ,e, (∃ τ, τ', s.t. Γ⊢e:τ ∧ Γ⊢e:τ'⟹τ=τ')$.
证明: 归纳即可, 由于变量 $x$ 在上下文 $Γ$ 中仅有一个类型 $τ$.

赋型判断是语法指导的, 也就是说, 赋型判断规则完全由语法结构决定,
这使得语法结构可以推断出类型信息.
引理 (4.2, 赋型反转 Inversion) : 如果 $Γ⊢\text{plus}(e_1, e_2):τ$, 那么 $τ=\text{nat}, Γ⊢e_1:\text{nat}, Γ⊢e_1:\text{nat}$
证明: 归纳即可, 可以参考引理 (2.1)的证明.


引理 (4.3, 弱化 Weakening) : 如果 $Γ⊢e':τ'$, 那么 $Γ, x:τ⊢e':τ'$.
证明: 对 $Γ⊢e':τ'$ 归纳.
引理 (4.4, 代换 Substitution) : 如果 $Γ, x:τ⊢e':τ'$, 那么 $Γ⊢[e/x]e':τ'$.
证明: 对 $Γ, x:τ⊢e':τ'$ 归纳.
引理 (4.4)指出了程序分离实现的可能性, 尽管我们现在还没有函数,
但是 let 运算符离函数只差一步, 之后我们会看到函数或者说代换的重要,
PFPL 称为 **模块化 Modularity** 和 **链接 Linking**.
引理 (4.4)的逆命题称为 **分解 Decomposition**:
引理 (4.5 分解 Decompostion) : 如果 $Γ⊢[e/x]e':τ'$, 那么 $∀τ$ 满足 $Γ⊢e:τ$, 有 $Γ, x:τ⊢e':τ'$.
尽管我们知道, 这里的 $τ$ 若有, 至多一个, 这是由引理 (4.1, 赋得型唯一)确定的.

引理 (4.3)(4.4)以及 **标识约定 identification convention** 保证了赋型判断是泛型归纳定义的判断.

### 类型安全
在动态语义中, 我们反复提到 **消去 Elimination**,现在说明 **引入 Introduction** 与 **消去 Elimination** :
某种类型的引入形式用以确定该类型的值, 而消去形式负责使用该值产生新值(可能是其他类型).

**值 value**, 有时又被称为 **规范形式 Canonical Form**, 简称 **范式**.


闭式 $e$ 称为 **良赋型 well-typed** 当且仅当 $∃τ,∀Γ,Γ⊢e:τ$ 当且仅当 $∃τ, ⊢e:τ$,
**良赋型 well-typed** 也称 **可赋型 typable**. 注意空上下文 $⊢e:τ$, 略去$⊢$, 记作$e:τ$.
闭式 $e$ 称为 **病态定义 ill-defined** 当且仅当 $∃e', e↦^*e'$, $e'$ 停顿, 且 $e'$ 不是值.
闭式 $e$ 称为 **良定义 well-defined** 当且仅当 $e$ 不是病态定义的, 即:
$∀e', e↦^*e'$, $e'$要么是值, 要么可以转换, 即 $∃ e'', e'↦e''$.

定理 (6.1, 类型安全 Type Safety) : 如果闭式 $e$ **良赋型 well-typed**, 那么 $e$ **良定义 well-defined**.
证明: 假设闭式 $e$ 良赋型, 即 $e:τ$, 我们要证 $∀e', e↦^*e'⟹e' \text{ val } ∨ ∃ e'', e'↦e''$.
令 $P(e, e')=e:τ⟹e' \text{ val } ∨ ∃ e'', e'↦e''$, 对 $e↦^*e'$ 归纳^[??]^:

1. (**进展 Progress**) 如果 $e:τ$, 要么 $e \text{ val}$, 要么 $∃e', e↦e'$;
2. (**保持 Preservation**) 如果 $e:τ$ 且 $∃e', e↦e'$, 那么 $e':τ$.

下面的引理证明均需要用到引理 (4.2, 赋型反转 Inversion).
引理 (6.2 **保持 Preservation**) : 如果 $e:τ$ 且 $e↦e'$, 那么 $e':τ$.
证明: 命题等价于 $e↦e'⟹e:τ⟹e':τ$,
令 $P(e,e')=e:τ⟹e':τ$对 $e↦e'$ 归纳即可.

引理 (6.3 **范式 Canonical Form**) : 如果 $e \text{ val}$ 且 $e:τ$, 那么
- $τ=\text{nat}⟹∃n, e=\text{nat[n]}$;
- $τ=\text{bool}⟹e=\text{true} ∨ e=\text{false}$.

证明: 对 $e \text{ val}$ 与 $e:τ$ 进行归纳.

引理 (6.4 **进展 Progress**) : 如果 $e:τ$, 要么 $e \text{ val}$, 要么 $∃e', e↦e'$.
证明: 对 $e:τ$ 进行归纳.


一般地, 我们把这里定义的类型安全称为 **类型有效 Type Soundness**,
这是因为被赋予类型的闭式运行不会卡住;
反过来, 若运行不会卡住的闭式能够被赋予类型,
即 **良定义** $⟹$ **良赋型**, 称为 **类型完备 Type Completeness**.

### 再说运行时错误
如果一个语言的静态语义能够完全决定动态语义不卡住, 那再好不过, 但总有例外.
例如, 我们拓展运算到有理数域, 引入除法 $\text{div}(e_1; e_2)$, 
而静态语义不能获得 $e_2$ 的值, 若动态语义求值为$\text{num}[0]$, 除以 $0$ 会导致类型错误.

对于动态语义卡住, 或者说运行时错误, 在求值动态语义时引入了错误表达式 $\text{error}$;
而在结构化动态语义下, 我们会添加一个具有传递性的判断 $e \text{ err}$.
求值动态语义处理错误时需要显式引入错误运算符 $\text{error}$,
结构化动态语义处理错误时只需说其**卡住**, 并且在有运行时错误时引入 $e \text{ err}$.
定理 (6.5 带错误的进展) 如果 $e:τ$, 要么 $e \text{ val}$, 要么 $e \text{ err}$, 要么 $∃e', e↦e'$.
证明: 类似归纳有之.

反过来, 现在假设没有运行时错误, 使用结构化动态语义则不必引入$e \text{ err}$,
但使用求值动态语义则不得不仿照引入 $\text{error}$ 一般引入 $e \text{ err}$.
假如我们为求值动态语义引入类似的判断 $e \text{ err}$, 那么每一条规则对应一条错误.
我们可以得到(其证明仍是归纳法):
定理 (7.5) 如果 $e \text{ err}$, 那么不存在$τ, s.t.e:τ$. 等价地有, 如果$e:τ$, 那么 $¬ (e \text{ err})$.
这一定理看似非常好, 但实际上, 如果 $e \text{ err}$ 写少了一条规则, 仍有上述定理.
这意味着, 如果 $e \text{ err}$ 没有覆盖所有编译时错误, 那么实际运行时仍然会出错,
而 $\text{ error}$ 的定义考虑了所有的计算可能性, 即模式匹配的完备性,
不妨回想[求值动态语义](E-dynamic-semantics.md#求值动态语义)一节中的 C++ 伪代码:
```C++
// ...
    default: return new AST::ERROR();
// ...
```