## 积类型 Product Types

### 序幕 Prelude
引入 **积类型 Product Types** 的需求是复合已有的数据结构. 
这里的积, 可以理解为 **笛卡尔积 Cartesian Product**, 或者说 **元组 Tuple**. 

我们当然可以考虑 n 元组, 其中 n=0, 1, ... 为任意的自然数. 
不过, 出于复合的需求, 我们期望至少是 2 元组, 而且任意的 n≥3 元组都可以用 2元组表示, 例如 (1, 2, 3) = (1, (2, 3)), 方便起见, 我们考虑 2 元组. 
另外, 0 元组也是需要的, 例如函数定义时, 可以视作一个不需要的参数, 更多的用处或许在 **和类型 Sum Types** 时才会出现. 0 元组的词项有且仅有一个, 因而我们称 0 元组类型为 **单位类型 unit types**.

积类型有许多用处, 例如使用名字索引的 **记录类型 Record Types**, 如 C 语言中的 `struct`; 又如多参数、多返回值函数类型, 这出现在那些不支持函数作为一等公民的语言中, 他们相较 λ 演算少了 Currying 的方法.

### 语法 Syntax
一般来说, 积类型是某个语言的拓展, 我们仅考量积类型涉及的语法.

||抽象语法|具体语法|
|:-:|:-:|:-:|
|词项$e$|
|0元组, 单位|triv|$⟨⟩$|
|2元组, 对子|pair($e_1; e_2$)|$⟨e_1, e_2⟩$|
|左投影|pr\[L]($e$)|$e$.L|
|右投影|pr\[R]($e$)|$e$.R|
|类型$τ$|||
|单位类型|unit|$\text{unit}$|
|乘积类型|prod($τ_1;τ_2$)|$τ_1 × τ_2$|

### 动态语义 Dynamic Semantics
首先是值判断:
$$
\tag{10.2a}
\dfrac
{}
{⟨⟩\text{ val}}
$$

$$
\tag{10.2b}
\dfrac
{[e_1 \text{ val}]\ [e_2 \text{ val}]}
{⟨e_1, e_2⟩\text{ val}}
$$
其中(10.2b)中的[ ]部分, 若包含, 则是急迫语义; 若不包括, 则是惰性语义.
这关键是在判断形如 $⟨0, 1+1⟩$ 的元组(假设为语言 E 拓展积类型)是否为值:惰性语义认为其为值, $1+1$的求值应当留至元组解构时进行; 急迫语义认为其不是值, 要求立即将其求值为 $⟨0, 2⟩$.

接下来是小步语义.
下列两条是急迫语义下对元组元素求值:
$$
\tag{10.2c, d}
\left[
\dfrac
{e_1↦e_1'}
{⟨e_1, e_2⟩↦⟨e_1', e_2⟩}
\right]
; \
\left[
\dfrac
{e_1\text{ val}\ e_2↦e_2'}
{⟨e_1, e_2⟩↦⟨e_1, e_2'⟩}
\right]
$$
下列四条规则处理元组的解构:
$$
\tag{10.2e, g}
\dfrac
{e↦e'}
{e.\text{L}↦e'.\text{L}}
; \
\dfrac
{[e_1 \text{ val}]\ [e_2 \text{ val}]}
{⟨e_1, e_2⟩.\text{L}↦e_1}
$$

$$
\tag{10.2f, h}
\dfrac
{e↦e'}
{e.\text{R}↦e'.\text{R}}
; \
\dfrac
{[e_1 \text{ val}]\ [e_2 \text{ val}]}
{⟨e_1, e_2⟩.\text{R}↦e_2}
$$

其中 (10.2g, h)中的急迫语义要求解构的元组内部元素必须全为值, 惰性语义则不必.
(10.2e, f) 二者在惰性语义中也是必须的, 因为除去积类型拓展的语义, 原语言的语义也可能需要化简$e$, 例如$e=(\lambda (x:\tau).e_2)\ e_1$.

### 静态语义 Static Semantics
$$
\tag{10.1a}
\dfrac
{}
{Γ⊢⟨⟩:\text{unit}}
$$

$$
\tag{10.2b}
\dfrac
{Γ⊢e_1:τ_1 \ Γ⊢e_2:τ_2}
{Γ⊢⟨e_1, e_2⟩:τ_1 × τ_2}
$$

$$
\tag{10.2c, d}
\dfrac
{Γ⊢e:τ_1 × τ_2}
{Γ⊢e.\text{L}:τ_1}
; \
\dfrac
{Γ⊢e:τ_1 × τ_2}
{Γ⊢e.\text{R}:τ_2}
$$

引理 (**保持 Preservation**) : 如果 $e:τ$ 且 $e↦e'$, 那么 $e':τ$.
引理 (**进展 Progress**) : 如果 $e:τ$, 要么 $e \text{ val}$, 要么 $∃e', e↦e'$.

### 杂言 Miscs
1. PFPL 10.2 中所述有限积不过是 n 元组并赋予索引, 即序幕中所言的 **记录类型 Record Types**, 类似地可以进行拓展. 唯一需要注意的是, 当进行急迫求值时, 基于索引的记录类型需要一个求值顺序, 此时只需给索引分配一个顺序即可.
2. PFPL 10.3 中所述原始互递归函数与[系统T](./T.md)有关.  原始递归函数通过某一特定的方式来进行函数的递归调用, 且能保证这些函数可停机, 因而称原始递归函数. 原始递归函数的递归方式与 λ 演算的 $Y$ 算子、C语言等均不同, 是从语言层面定义递归.
对原始递归函数不甚熟悉者可以暂时忽略原书这一部分. 与积类型相关的思路叙述如下:
原始互递归函数是在原始递归函数的基础上, 将递归的方式进行积类型的打包, 直观上传递了函数元组$⟨f_1, f_2⟩$, 当需要时再从元组中解构某一, 例如互递归定义奇偶判断 even 和 odd, 在 even 中调用函数 $⟨$even, odd$⟩$.R = odd 即可. 